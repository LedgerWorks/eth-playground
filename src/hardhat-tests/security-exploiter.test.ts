import "@nomicfoundation/hardhat-chai-matchers";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { expect } from "chai";
import { ethers } from "hardhat";

describe("SecurityExploiter", () => {
  async function deploy() {
    // Contracts are deployed using the first signer/accounts by default
    const [owner, exploiter, intermediary] = await ethers.getSigners();

    const SecurityMistakesErc20 = await ethers.getContractFactory("SecurityMistakesERC20");
    const initialSupply = 350;
    const securityMistakesContract = await SecurityMistakesErc20.deploy(initialSupply);

    const SecurityExploiter = await ethers.getContractFactory("SecurityExploiter");
    const securityExploiterContract = await SecurityExploiter.deploy();

    return {
      securityMistakesContract,
      securityExploiterContract,
      initialSupply,
      owner,
      exploiter,
      intermediary,
    };
  }

  describe("exploitTranferFrom", () => {
    it("should remove balance from the holder", async () => {
      const {
        securityMistakesContract,
        securityExploiterContract,
        owner,
        exploiter,
        initialSupply,
      } = await loadFixture(deploy);

      await securityExploiterContract
        .connect(exploiter)
        .exploitTransferFrom(securityMistakesContract, owner.address, exploiter.address, 100);

      const ownerBalance = await securityMistakesContract.balanceOf(owner.address);
      expect(ownerBalance).to.equal(initialSupply - 100);
      const exploiterBalance = await securityMistakesContract.balanceOf(exploiter.address);
      expect(exploiterBalance).to.equal(100);
    });

    it("should allow multi-hop transfer from the holder", async () => {
      const {
        securityMistakesContract,
        securityExploiterContract,
        owner,
        exploiter,
        intermediary,
        initialSupply,
      } = await loadFixture(deploy);

      await securityExploiterContract
        .connect(exploiter)
        .launderTransferFrom(
          securityMistakesContract,
          owner.address,
          intermediary.address,
          exploiter.address,
          100
        );

      const ownerBalance = await securityMistakesContract.balanceOf(owner.address);
      expect(ownerBalance).to.equal(initialSupply - 100);
      const intermediaryBalance = await securityMistakesContract.balanceOf(intermediary.address);
      expect(intermediaryBalance).to.equal(0);
      const exploiterBalance = await securityMistakesContract.balanceOf(exploiter.address);
      expect(exploiterBalance).to.equal(100);
    });
  });
});
