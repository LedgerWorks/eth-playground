import "@nomicfoundation/hardhat-chai-matchers";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { expect } from "chai";
import { ethers } from "hardhat";

describe("Kinetic Exploit", () => {
  async function deployContract() {
    const [owner, otherAccount] = await ethers.getSigners();

    const KineticExploitTesterFactory = await ethers.getContractFactory("KineticExploitTester");

    const contract = await KineticExploitTesterFactory.deploy();

    return { contract, owner, otherAccount };
  }

  function asFixedPointBigInt(value: number, decimals: number): bigint {
    return BigInt(value * 10 ** decimals);
  }

  function assertOnResult(result: [bigint, bigint], expectedExchangeRate: bigint) {
    expect(result[0]).to.equal(0);
    expect(result[1]).to.equal(expectedExchangeRate);
  }

  describe("getExchangeRate", () => {
    /**
     * This test shows that price manipulation doesn't occur when relatively whole numbers are used
     * In this test, the exchange rate is 1 underlying = 0.5 cToken
     */
    it("price manipulation is not evident when exchange rate is simple", async () => {
      const { contract } = await loadFixture(deployContract);

      // The equation to determine exchange rate
      // (total cash + total borrows - total reserves) / total supply
      const cTokenDecimals = 8;
      const underlyingDecimals = 18;
      const baselineTotalCash = asFixedPointBigInt(800, underlyingDecimals);
      const baselineTotalBorrow = asFixedPointBigInt(500, underlyingDecimals);
      const baselineTotalReserves = asFixedPointBigInt(300, underlyingDecimals);
      const baselineTotalSupply = asFixedPointBigInt(2000, cTokenDecimals);
      const baselineResult = await contract.getExchangeRate(
        baselineTotalCash,
        baselineTotalBorrow,
        baselineTotalReserves,
        baselineTotalSupply
      );

      // 1 underlying = 0.5 cToken
      // 0.5 * 1E18 = 500000000000000000
      const expectedExchangeRate = BigInt("5000000000000000000000000000");
      assertOnResult(baselineResult, expectedExchangeRate);

      // Withdraw 100 underlying = 200 cToken
      // Validate exchange rate doesn't change
      const smallWithdrawalUnderlying = asFixedPointBigInt(100, underlyingDecimals);
      const smallWithdrawalCToken = asFixedPointBigInt(200, cTokenDecimals);
      const newTotalCash = baselineTotalCash - smallWithdrawalUnderlying;
      const newTotalSupply = baselineTotalSupply - smallWithdrawalCToken;
      const resultSmallWithdrawal = await contract.getExchangeRate(
        newTotalCash,
        baselineTotalBorrow,
        baselineTotalReserves,
        newTotalSupply
      );
      assertOnResult(resultSmallWithdrawal, BigInt("5000000000000000000000000000"));
    });

    it("should show price manipulation occurring with small withdrawals", async () => {
      const { contract } = await loadFixture(deployContract);

      // The equation to determine exchange rate
      // (total cash + total borrows - total reserves) / total supply
      // Taking a snapshot in time when the exploit occurred; the exchange rate was 2.002075601427474712
      const cTokenDecimals = 8;
      const underlyingDecimals = 18;
      const baselineTotalCash = asFixedPointBigInt(800, underlyingDecimals);
      const baselineTotalBorrow = asFixedPointBigInt(500, underlyingDecimals);
      const baselineTotalReserves = asFixedPointBigInt(300, underlyingDecimals);
      const baselineTotalSupply = asFixedPointBigInt(4994816376000, cTokenDecimals);
      const baselineResult = await contract.getExchangeRate(
        baselineTotalCash,
        baselineTotalBorrow,
        baselineTotalReserves,
        baselineTotalSupply
      );

      assertOnResult(baselineResult, BigInt("2002075601427474712"));

      // Withdraw small amount with exchange rate of 1 underlying = 49.94816376 cToken
      // Validate this withdrawal actually changes the exchange rate
      const smallWithdrawalUnderlying = asFixedPointBigInt(1, underlyingDecimals);
      const smallWithdrawalCToken = asFixedPointBigInt(49.94816376, cTokenDecimals);
      const newTotalCash = baselineTotalCash - smallWithdrawalUnderlying;
      const newTotalSupply = baselineTotalSupply - smallWithdrawalCToken;
      const resultSmallWithdrawal = await contract.getExchangeRate(
        newTotalCash,
        baselineTotalBorrow,
        baselineTotalReserves,
        newTotalSupply
      );
      assertOnResult(resultSmallWithdrawal, BigInt("2000073525846047973"));
    });
  });
});
